
// Type: com.digitalarcsystems.Traveller.DataModel.Outcome




using com.digitalarcsystems.Traveller.DataModel.Equipment;
using com.digitalarcsystems.Traveller.utility;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

#nullable disable
namespace com.digitalarcsystems.Traveller.DataModel
{
  public class Outcome : IDescribable
  {
    [JsonProperty]
    protected string _name = string.Empty;
    [JsonProperty]
    protected string _description = string.Empty;

    [JsonIgnore]
    public bool Recorded { get; set; }

    public Outcome()
    {
    }

    public Outcome(string name, string description)
    {
      this._name = name;
      this._description = description;
    }

    public override string ToString() => Utility.toTitleCase(this.GetType().Name);

    public virtual void handleOutcome(GenerationState currentState)
    {
      currentState.recorder.RecordBenefit(this, currentState);
      EngineLog.Print("Unhandled Outcome:" + this?.ToString());
    }

    [JsonProperty]
    public virtual string Name
    {
      get => string.IsNullOrEmpty(this._name) ? this.AutoGenerateName() : this._name;
      set => this._name = value;
    }

    protected virtual string AutoGenerateName() => Utility.toTitleCase(this.GetType().Name);

    [JsonProperty]
    public virtual string Description
    {
      get
      {
        return string.IsNullOrEmpty(this._description) ? this.AutoGenerateDescription() : this._description;
      }
      set => this._description = value;
    }

    protected virtual string AutoGenerateDescription() => this.GetType().Name;

    public class IncreaseAnyExistingSkill : Outcome
    {
      [JsonConstructor]
      public IncreaseAnyExistingSkill()
      {
        this.Name = "Increase any skill";
        this.Description = "Any skill you know (except \"Jack-of-All-Trades\") can be upgraded by one level";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        List<ISkill> second = new List<ISkill>()
        {
          currentState.skillSource.getSkill("Jack-of-all-Trades")
        };
        List<ISkill> list = currentState.character.Skills.Except<ISkill>((IEnumerable<ISkill>) second).ToList<ISkill>();
        ISkill skill = currentState.decisionMaker.ChooseOne<ISkill>((IList<ISkill>) list);
        try
        {
          new Outcome.GainSkill(currentState.skillSource.getSkill(skill.Name)).handleOutcome(currentState);
        }
        catch (Exception ex)
        {
          throw ex;
        }
      }
    }

    public class IncreaseAnyExistingTalent : Outcome
    {
      [JsonConstructor]
      public IncreaseAnyExistingTalent()
      {
        this.Name = "Increase any Talent";
        this.Description = "Any Talent you know can be upgraded by one level";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        IList<Talent> list = (IList<Talent>) currentState.character.Talents.ToList<Talent>();
        if (list.IsNullOrEmpty<Talent>())
        {
          if (currentState.character.Race.Name.Contains("Zhodani"))
          {
            try
            {
              new Outcome.GainAnyZhodaniTalent().handleOutcome(currentState);
            }
            catch (Exception ex)
            {
              throw ex;
            }
          }
          else
          {
            try
            {
              new Outcome.GainAnyTalent().handleOutcome(currentState);
            }
            catch (Exception ex)
            {
              throw ex;
            }
          }
        }
        else
        {
          try
          {
            new Outcome.GainTalent(currentState.decisionMaker.ChooseOne<Talent>(list).Name).handleOutcome(currentState);
          }
          catch (Exception ex)
          {
            throw ex;
          }
        }
      }
    }

    public class RandomChoice : Outcome
    {
      [JsonProperty]
      public IList<Outcome> choices;

      [JsonConstructor]
      public RandomChoice()
      {
      }

      public RandomChoice(params Outcome[] outcomes) => this.choices = (IList<Outcome>) outcomes;

      public RandomChoice(string title, string description, params Outcome[] outcomes)
        : this(outcomes)
      {
        this.Name = title;
        this._description = description;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        Dice.RollRandomResult<Outcome>("", this.choices, ContextKeys.OUTCOMES).handleOutcome(currentState);
      }
    }

    public class StatModified : Outcome
    {
      [JsonProperty]
      public string statName;
      [JsonProperty]
      public int modifier;

      [JsonProperty]
      public int max_value { get; set; } = 99;

      protected override string AutoGenerateDescription()
      {
        return "Your " + this.statName + " will be changed by: " + this.modifier.ToString();
      }

      protected override string AutoGenerateName()
      {
        return this.statName + " " + this.modifier.ToString();
      }

      public StatModified()
      {
      }

      [JsonConstructor]
      public StatModified(string stat, int amount)
      {
        this.statName = stat;
        this.modifier = amount;
      }

      public StatModified(string stat, int amount, int not_to_exceed)
      {
        this.statName = stat;
        this.modifier = amount;
        this.max_value = not_to_exceed;
      }

      public StatModified(string stat, int amount, string description)
        : this(stat, amount)
      {
        this._description = description;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        Attribute attribute = currentState.character.getAttribute(this.statName);
        if (attribute == null)
          throw new NullReferenceException("Stat [" + this.statName + "] wasn't found in [" + currentState.character.getAttributes()?.ToString() + "]");
        if (this.modifier >= 0)
        {
          if (attribute.Value + this.modifier <= this.max_value)
          {
            attribute.Value += this.modifier;
            attribute.UninjuredValue += this.modifier;
          }
          else
            currentState.decisionMaker.present(new Presentation(string.Format("Can't Raise {0}", (object) attribute), string.Format("You aren't allow to go above {0}", (object) this.max_value)));
        }
        else if (currentState.nextOperation == CreationOperation.HANDLE_AGING)
          attribute.Age(this.modifier);
        else
          attribute.Subtract(this.modifier);
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override string ToString()
      {
        return this.statName == null ? base.ToString() : this.statName + (this.modifier > 0 ? " +" : " ") + this.modifier.ToString();
      }
    }

    public class GainSkill : Outcome
    {
      [JsonProperty]
      public string skillName;
      [JsonProperty]
      public bool basic_training_skill;
      [JsonProperty]
      public int levelsToGain = 1;

      public override string Name
      {
        get
        {
          return string.IsNullOrEmpty(this._name) ? this.skillName + (this.basic_training_skill ? " 0 " : " + " + this.levelsToGain.ToString()) : base.Name;
        }
        set => base.Name = value;
      }

      [JsonConstructor]
      public GainSkill()
      {
      }

      protected override string AutoGenerateDescription()
      {
        ISkill skill = DataManager.Instance.Skills.Where<ISkill>((Func<ISkill, bool>) (s => s.Name.Equals(this.skillName, StringComparison.InvariantCultureIgnoreCase))).FirstOrDefault<ISkill>();
        string description = skill?.Description;
        if (skill == null)
        {
          EngineLog.Print("WARNING:  Couldn't find a skill matching the name [" + this.skillName + "] for GainSkill.AutogenerateDescription.  Ignoring.");
          Console.WriteLine("WARNING:  Couldn't find a skill matching the name [" + this.skillName + "] for GainSkill.AutogenerateDescription.  Ignoring.");
        }
        return "Gain + " + this.levelsToGain.ToString() + " Level(s) of " + this.skillName + ".\n" + (description ?? "");
      }

      public GainSkill(string skill) => this.skillName = skill;

      public GainSkill(ISkill skill)
        : this(skill.Name)
      {
      }

      public GainSkill(string skill, int level)
        : this(skill)
      {
        this.levelsToGain = level;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        ISkill skill1 = (ISkill) null;
        ISkillSource skillSource = currentState.skillSource;
        this.basic_training_skill = currentState.nextOperation == CreationOperation.GET_BASIC_TRAINING || currentState.nextOperation == CreationOperation.GAIN_BACKGROUND_SKILLS || currentState.nextOperation == CreationOperation.SELECT_RACE;
        try
        {
          if (this.basic_training_skill)
          {
            skill1 = skillSource.getBasicTrainingSkill(this.skillName);
          }
          else
          {
            skill1 = skillSource.getSkill(this.skillName);
            skill1.Level = this.levelsToGain;
          }
        }
        catch (Exception ex)
        {
          EngineLog.Print("Error finding Skill" + this.skillName + "\n" + ex.Message);
        }
        if (skill1 != null && skill1.Cascade && !this.basic_training_skill)
        {
          if (!currentState.character.hasSkill(skill1))
            currentState.character.addSkill(skillSource.getBasicTrainingSkill(this.skillName));
          currentState.decisionMaker.setQueryKey(ContextKeys.SKILLS);
          ISkill potentialFreeFormSkill = currentState.decisionMaker.ChooseOne<ISkill>("Which skill would you like to increase by " + this.levelsToGain.ToString() + ":", (IList<ISkill>) new List<ISkill>((IEnumerable<ISkill>) skill1.SpecializationSkills));
          if (potentialFreeFormSkill.Parent != skill1)
          {
            potentialFreeFormSkill.Parent = skill1;
            EngineLog.Error(potentialFreeFormSkill.Name + " didn't have the correct parent: " + skill1.Name);
          }
          ISkill skill2 = Utility.handleIfFreeFormSkill(potentialFreeFormSkill, currentState);
          skill2.Level = this.levelsToGain;
          skill1 = skill2;
        }
        else if (skill1.IsSpecialization && !currentState.character.hasSkill(skill1.Parent))
          currentState.character.addSkill(skillSource.getBasicTrainingSkill(skill1.Parent.Name));
        currentState.character.addSkill(skill1);
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override bool Equals(object amIEqual)
      {
        bool flag = false;
        if (amIEqual is Outcome.GainSkill)
        {
          Outcome.GainSkill gainSkill = (Outcome.GainSkill) amIEqual;
          if (this.skillName != null)
          {
            if (gainSkill != null && gainSkill.skillName.Equals(this.skillName, StringComparison.CurrentCultureIgnoreCase))
              flag = true;
          }
          else if (gainSkill.skillName == null)
            flag = true;
        }
        return flag;
      }

      public override int GetHashCode()
      {
        return typeof (Outcome.GainSkill).GetHashCode() + (this.skillName != null ? this.Name.GetHashCode() : 19);
      }

      public override string ToString() => this.Name;
    }

    public class SelectSkillToGain : Outcome
    {
      [JsonProperty]
      public int numToSelect = 1;
      [JsonProperty]
      public List<string> skills;
      [JsonProperty]
      public string parentName;

      protected override string AutoGenerateName()
      {
        StringBuilder stringBuilder = new StringBuilder("[");
        bool flag = true;
        foreach (string skill in this.skills)
        {
          if (!flag)
            stringBuilder.Append(", ");
          else
            flag = false;
          stringBuilder.Append(skill);
        }
        stringBuilder.Append("]");
        return stringBuilder.ToString();
      }

      protected override string AutoGenerateDescription()
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append("Available choices are: ");
        bool flag = true;
        foreach (string skill in this.skills)
        {
          if (flag)
          {
            flag = false;
            stringBuilder.Append(skill + " ");
          }
          else
            stringBuilder.Append(", " + skill);
        }
        return stringBuilder.ToString();
      }

      [JsonConstructor]
      public SelectSkillToGain()
      {
      }

      public SelectSkillToGain(int numSkills, params string[] skillsListToAdd)
      {
        this.numToSelect = numSkills;
        this.skills = ((IEnumerable<string>) skillsListToAdd).ToList<string>();
      }

      protected List<ISkill> obtainActualSkills(GenerationState currentState)
      {
        List<ISkill> actualSkills = new List<ISkill>();
        foreach (string skill in this.skills)
        {
          if (currentState.nextOperation == CreationOperation.SELECT_RACE || currentState.nextOperation == CreationOperation.GAIN_BACKGROUND_SKILLS || currentState.nextOperation == CreationOperation.GET_BASIC_TRAINING)
            actualSkills.Add(currentState.skillSource.getBasicTrainingSkill(skill));
          else
            actualSkills.Add(currentState.skillSource.getSkill(skill));
        }
        return actualSkills;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        List<ISkill> actualSkills = this.obtainActualSkills(currentState);
        currentState.decisionMaker.setInfoForUI(CreationOperation.CHOOSE_ONE_FREE_SKILL);
        foreach (IDescribable describable in (IEnumerable<ISkill>) currentState.decisionMaker.Choose<ISkill>(this.numToSelect, (IList<ISkill>) actualSkills))
          new Outcome.GainSkill(describable.Name).handleOutcome(currentState);
      }

      public override string ToString()
      {
        if (this.skills == null || this.skills.Count == 0)
          return Utility.toTitleCase(this.GetType().Name);
        StringBuilder stringBuilder = new StringBuilder("");
        if (string.IsNullOrEmpty(this._name))
        {
          if (this.parentName != null && this.parentName.Count<char>() > 0)
            stringBuilder.Append(this.parentName);
          stringBuilder.Append("(");
          bool flag = true;
          foreach (string skill in this.skills)
          {
            if (flag)
            {
              flag = false;
              stringBuilder.Append(skill + " ");
            }
            stringBuilder.Append(", " + skill);
          }
          stringBuilder.Append(")");
        }
        else
          stringBuilder.Append(this._name);
        return stringBuilder.ToString();
      }

      public override bool Equals(object obj)
      {
        if (obj == this)
          return true;
        bool flag = false;
        if (obj is Outcome.SelectSkillToGain)
        {
          Outcome.SelectSkillToGain selectSkillToGain = (Outcome.SelectSkillToGain) obj;
          if (this.numToSelect == selectSkillToGain.numToSelect)
          {
            if (this.skills == null && selectSkillToGain.skills == null)
              flag = false;
            else if (this.skills != null && selectSkillToGain.skills == null || this.skills == null && selectSkillToGain.skills != null)
              flag = false;
            else if (this.skills.Count == selectSkillToGain.skills.Count)
            {
              flag = true;
              foreach (string skill in this.skills)
              {
                if (!selectSkillToGain.skills.Contains(skill))
                {
                  flag = false;
                  break;
                }
              }
            }
          }
        }
        return flag;
      }

      public override int GetHashCode()
      {
        return this.numToSelect == 0 || this.skills == null ? 0 : this.numToSelect.GetHashCode() * this.skills.GetHashCode() / int.MaxValue;
      }
    }

    public class SelectSkillToEnsure : Outcome.SelectSkillToGain
    {
      [JsonProperty]
      public int level_to_ensure = 1;

      public SelectSkillToEnsure()
      {
      }

      public SelectSkillToEnsure(int numToSelect, params string[] skills)
        : base(numToSelect, skills)
      {
      }

      public SelectSkillToEnsure(
        string title,
        string description,
        int level,
        params string[] skills)
        : base(1, skills)
      {
        this.level_to_ensure = level;
        this._description = description;
        this._name = title;
      }

      public SelectSkillToEnsure(
        string title,
        string description,
        int level,
        string[] skills,
        int numToSelect)
        : base(numToSelect, skills)
      {
        this.level_to_ensure = level;
        this._description = description;
        this._name = title;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        List<ISkill> source = new List<ISkill>();
        foreach (string skill1 in this.skills)
        {
          ISkill skill2 = currentState.skillSource.getSkill(skill1);
          if (skill2 == null)
          {
            EngineLog.Error("Gain Any Skill, Unidentified Skill [" + skill1 + "],  Skipping.");
          }
          else
          {
            if (skill2 is ReadOnlySkillAdapter)
              skill2 = (ISkill) ((ReadOnlySkillAdapter) skill2).Clone();
            source.Add(skill2);
          }
        }
        List<Outcome> list = Utility.prune<ISkill>((IList<ISkill>) source, currentState.character.Skills, this.level_to_ensure).Cast<ISkill>().Select<ISkill, Outcome.EnsureSkillAtLevel>((Func<ISkill, Outcome.EnsureSkillAtLevel>) (skill => new Outcome.EnsureSkillAtLevel(skill.Name, this.level_to_ensure))).Cast<Outcome>().ToList<Outcome>();
        if (list.Count != 0)
        {
          currentState.decisionMaker.setInfoForUI(CreationOperation.CHOOSE_ONE_FREE_SKILL);
          foreach (Outcome outcome in (IEnumerable<Outcome>) currentState.decisionMaker.Choose<Outcome>("Pick " + this.numToSelect.ToString() + " skill" + (this.numToSelect > 1 ? "s" : "") + " to have at level " + this.level_to_ensure.ToString(), this.numToSelect, (IList<Outcome>) list))
            outcome.handleOutcome(currentState);
        }
        else
          new Event("Already know everything", "You didn't pick up a new skill because you already know " + this.skills.ToString() + " at or above level " + this.level_to_ensure.ToString()).handleOutcome(currentState);
      }
    }

    public class EnsureSkillAtLevel : Outcome, ISingleIntOutcome, ISingleTextOutcome
    {
      public int minLevel;

      [JsonConstructor]
      public EnsureSkillAtLevel()
      {
      }

      public EnsureSkillAtLevel(string skill, int skillLevel)
      {
        this.Text = skill;
        this.minLevel = skillLevel;
      }

      protected override string AutoGenerateName()
      {
        return "Ensure " + this.Text + " at level " + this.minLevel.ToString();
      }

      protected override string AutoGenerateDescription()
      {
        return "You will gain the " + this.Text + " skill at level " + this.minLevel.ToString() + ". If you are already level 1 or higher, your skill will not improve.";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        Character character = currentState.character;
        ISkill skill1 = currentState.skillSource.getSkill(this.Text);
        if (skill1.Cascade && this.minLevel > 0)
        {
          ISkill skill2 = skill1;
          new Outcome.SelectSkillToEnsure("Which skill would you like to ensure is at least " + this.minLevel.ToString() + "?", "Select 1", this.minLevel, skill2.SpecializationSkills.Select<ISkill, string>((Func<ISkill, string>) (s => s.Name)).ToArray<string>()).handleOutcome(currentState);
        }
        else
        {
          ISkill skill3 = Utility.handleIfFreeFormSkill(skill1, currentState);
          if (character.hasSkill(skill3))
          {
            ISkill skill4 = character.getSkill(skill3.Name);
            if (skill4 == null)
              EngineLog.Print("We have a problem");
            if (skill4.Level < this.minLevel)
              skill4.Level = this.minLevel;
          }
          else
          {
            skill3.Level = this.minLevel;
            character.addSkill(skill3);
            if (skill3.IsSpecialization && skill3.Level > 0 && !currentState.character.hasSkill(skill3.Parent))
              currentState.character.addSkill(currentState.skillSource.getBasicTrainingSkill(skill3.Parent.Name));
          }
        }
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override string ToString()
      {
        return "Ensure [" + this.Text + "] at least " + this.minLevel.ToString();
      }

      public virtual int Int
      {
        set => this.minLevel = value;
        get => this.minLevel;
      }

      public virtual string IntLabel => !string.IsNullOrEmpty(this.Text) ? this.Text : "Skill Name";

      public virtual string Text { get; set; }

      public virtual string TextLabel => "Skill Name";
    }

    public class GainMoney : Outcome, ISingleIntOutcome
    {
      [JsonProperty]
      public int amount;

      protected override string AutoGenerateName() => this.amount.ToString() + " credits.";

      protected override string AutoGenerateDescription()
      {
        return "You will get " + this.amount.ToString() + " imperial credits. Money never hurts, no matter where it comes from.";
      }

      [JsonConstructor]
      public GainMoney()
      {
      }

      public GainMoney(int credits) => this.amount = credits;

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.character.Credits += this.amount;
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override string ToString() => "Gained " + this.amount.ToString() + " credits";

      public virtual int Int
      {
        set => this.amount = value;
        get => this.amount;
      }

      public virtual string IntLabel => "Credits";
    }

    public class AdvancementModifier : Outcome, ISingleIntOutcome
    {
      public int modifier;

      protected override string AutoGenerateName() => this.ToString();

      protected override string AutoGenerateDescription()
      {
        return "At the end of your term, your change of advancement will be higher. Your Advancement Roll will be modified by " + this.modifier.ToString() + ".";
      }

      [JsonConstructor]
      public AdvancementModifier()
      {
      }

      public AdvancementModifier(int rollModifier) => this.modifier = rollModifier;

      public AdvancementModifier(int rollModifier, string description)
        : this(rollModifier)
      {
        this._description = description;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.character.CurrentTerm.advancementModifier += this.modifier;
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override string ToString()
      {
        return "Advancement Modifier [" + this.modifier.ToString() + "]";
      }

      public virtual int Int
      {
        set => this.modifier = value;
        get => this.modifier;
      }

      public virtual string IntLabel => (string) null;
    }

    public class SkipAdvancement : Outcome
    {
      public override void handleOutcome(GenerationState currentState)
      {
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
        currentState.skipProcessAdvancementOrCommission = true;
      }
    }

    public class QualificationModifier : Outcome, ISingleIntOutcome
    {
      [JsonProperty]
      public int modifier;

      protected override string AutoGenerateName()
      {
        return "Qualification modifier of " + this.modifier.ToString();
      }

      protected override string AutoGenerateDescription()
      {
        return "Your change of qualification will increase. Your Qualification Roll will be modified by " + this.modifier.ToString();
      }

      [JsonConstructor]
      public QualificationModifier()
      {
      }

      public QualificationModifier(int qualificationModifier)
      {
        this.modifier = qualificationModifier;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.qualificationModifiers["ANY"] += this.modifier;
      }

      public override string ToString()
      {
        return "Qualification Modifier [" + this.modifier.ToString() + "]";
      }

      public virtual int Int
      {
        set => this.modifier = value;
        get => this.modifier;
      }

      public virtual string IntLabel => (string) null;
    }

    public class MusteringOutBenefitRollModifier : Outcome, ISingleIntOutcome
    {
      [JsonProperty]
      public int modifier;

      [JsonConstructor]
      public MusteringOutBenefitRollModifier()
      {
      }

      public MusteringOutBenefitRollModifier(int rollModifier) => this.modifier = rollModifier;

      protected override string AutoGenerateName()
      {
        return "Mustering out modifier [" + this.modifier.ToString() + "]";
      }

      protected override string AutoGenerateDescription()
      {
        return "During mustering out, and rolling for benefits, one of your rolls will be augmented by " + this.modifier.ToString() + ". When did you become such a suck-up?";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.character.CurrentTerm.musteringOutBenefitRollModifierCurrentTerm = this.modifier;
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override string ToString()
      {
        return "One mustering out Benefit Roll at [" + this.modifier.ToString() + "]";
      }

      public virtual int Int
      {
        set => this.modifier = value;
        get => this.modifier;
      }

      public virtual string IntLabel => (string) null;
    }

    public class MusteringOutBenefitModifier : Outcome, ISingleIntOutcome
    {
      [JsonProperty]
      public int numOfBenefits;

      protected override string AutoGenerateName()
      {
        string name = this.numOfBenefits > 0 ? "Additional benefit" : "Lost benefit";
        if (Math.Abs(this.numOfBenefits) > 1)
          name = name + "s [" + this.numOfBenefits.ToString() + "]";
        return name;
      }

      protected override string AutoGenerateDescription()
      {
        if (this.numOfBenefits <= 0)
          return "We live in a cruel world - they just reduced your mustering out benefits by " + this.numOfBenefits.ToString() + ". You can use a better career, for sure!";
        string str = "You will gain additional benefit";
        if (this.numOfBenefits > 1)
          str = str + "s in number of " + this.numOfBenefits.ToString();
        return str + ". Everybody says you don't deserve it, but what do they know?";
      }

      [JsonConstructor]
      public MusteringOutBenefitModifier()
      {
      }

      public MusteringOutBenefitModifier(int num_of_benefits)
      {
        this.numOfBenefits = num_of_benefits;
      }

      public MusteringOutBenefitModifier(string title, string description, int num_of_benefits)
        : base(title, description)
      {
        this.numOfBenefits = num_of_benefits;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.character.CurrentTerm.additional_mustering_out_benefits += this.numOfBenefits;
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override string ToString()
      {
        return this.numOfBenefits > 0 ? "Gained " + this.numOfBenefits.ToString() + " mustering out benefit(s)." : "Lost" + this.numOfBenefits.ToString() + " mustering out benefit(s)";
      }

      public virtual int Int
      {
        set => this.numOfBenefits = value;
        get => this.numOfBenefits;
      }

      public virtual string IntLabel => (string) null;
    }

    public class AddTermWithRankAndTitle : Outcome
    {
      [JsonProperty]
      public int increase_by = 1;
      [JsonProperty]
      public string title = "Title";
      [JsonProperty]
      public string career_name = "Career";

      [JsonConstructor]
      public AddTermWithRankAndTitle()
      {
      }

      public AddTermWithRankAndTitle(int num_to_increase_by)
      {
        this.increase_by = num_to_increase_by;
      }

      public AddTermWithRankAndTitle(int num_to_increase_by, string rank_title)
        : this(num_to_increase_by)
      {
        this.title = rank_title;
      }

      public AddTermWithRankAndTitle(int num_to_increase_by, string rank_title, string career_name)
        : this(num_to_increase_by, rank_title)
      {
        this.career_name = career_name;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        Career newCareer = new Career(this.career_name, this.title, "");
        currentState.character.startNewTerm(newCareer);
        currentState.character.CurrentTerm.rank += this.increase_by;
        currentState.character.CurrentTerm.title = this.title;
        base.handleOutcome(currentState);
      }
    }

    public class AutomaticPromotionOrCommission : Outcome
    {
      [JsonProperty]
      public Outcome.AutomaticPromotionOrCommission.Choice apocChoice = Outcome.AutomaticPromotionOrCommission.Choice.CHOOSE;

      [JsonProperty]
      public bool AdditionalSkill { get; set; }

      public AutomaticPromotionOrCommission()
      {
        this.apocChoice = Outcome.AutomaticPromotionOrCommission.Choice.CHOOSE;
        this.AdditionalSkill = true;
      }

      [JsonConstructor]
      public AutomaticPromotionOrCommission(
        Outcome.AutomaticPromotionOrCommission.Choice choice,
        bool additional_skill = true)
      {
        this.apocChoice = choice;
        this.AdditionalSkill = additional_skill;
      }

      protected override string AutoGenerateName() => this.ToString();

      protected override string AutoGenerateDescription() => "Gain an automatic promotion!";

      public override void handleOutcome(GenerationState currentState)
      {
        Outcome outcome1 = (Outcome) new Event.GainPromotion("Promotion", this.Description);
        Outcome outcome2 = (Outcome) new Outcome.GainCommision("Commission", this.Description);
        if (!currentState.character.CurrentTerm.officer && currentState.currentCareer.hasCommissions() && this.apocChoice != Outcome.AutomaticPromotionOrCommission.Choice.PROMOTION_ONLY)
        {
          if (this.apocChoice == Outcome.AutomaticPromotionOrCommission.Choice.CHOOSE)
          {
            List<Outcome> choices = new List<Outcome>()
            {
              outcome1,
              outcome2
            };
            currentState.decisionMaker.ChooseOne<Outcome>("Do you wish to gain a commission (become an officer) or be promoted as an NCO?", (IList<Outcome>) choices).handleOutcome(currentState);
          }
          else
            outcome2.handleOutcome(currentState);
        }
        else
          outcome1.handleOutcome(currentState);
        if (!this.AdditionalSkill)
          return;
        currentState.decisionMaker.setInfoForUI(CreationOperation.CHOOSE_SKILLS_AND_TRAINING_TABLE_OBTAIN_SKILL);
        new Outcome.AdditionalRollOnSkillsAndTrainingTable().handleOutcome(currentState);
      }

      public override string ToString() => "Automatic Promotion";

      public enum Choice
      {
        CHOOSE,
        PROMOTION_ONLY,
        COMMISION_ONLY,
      }
    }

    public class GainCommision : Outcome
    {
      [JsonConstructor]
      public GainCommision()
      {
      }

      public GainCommision(string name, string description)
        : base(name, description)
      {
      }

      protected override string AutoGenerateName() => this.ToString();

      protected override string AutoGenerateDescription() => "You are so lucky!";

      public override void handleOutcome(GenerationState currentState)
      {
        Rank title = currentState.character.incrementRankAndGetTitle(currentState.currentCareer, true);
        if (title == null)
          return;
        foreach (Outcome benefit in title.benefits)
          benefit.handleOutcome(currentState);
      }

      public override string ToString() => "Commissioned";
    }

    public abstract class EntityToMeet : Outcome, ISingleIntOutcome
    {
      [JsonProperty]
      public int num = 1;

      protected override string AutoGenerateName() => this.ToString();

      protected override string AutoGenerateDescription() => this.ToString();

      public override string ToString()
      {
        string str = this.num.ToString() + " " + this.GetType().Name;
        if (this.num == 1)
        {
          if (str.LastIndexOf("ies", StringComparison.InvariantCultureIgnoreCase) > 0)
          {
            str = str.Remove(str.LastIndexOf("ies", StringComparison.InvariantCultureIgnoreCase), 3) + "y";
          }
          else
          {
            int startIndex = str.LastIndexOf("s", StringComparison.InvariantCultureIgnoreCase);
            str = str.Remove(startIndex);
          }
        }
        return str.ToString();
      }

      public virtual int Int
      {
        set => this.num = value;
        get => this.num;
      }

      public virtual string IntLabel => (string) null;
    }

    public class Contacts : Outcome.EntityToMeet
    {
      public Contacts(int number_of_contacts) => this.num = number_of_contacts;

      [JsonConstructor]
      public Contacts()
        : this(1)
      {
      }

      public override void handleOutcome(GenerationState currentState)
      {
        foreach (Contact contact in (IEnumerable<Contact>) currentState.peopleSource.getEntityToMeet(this.num, "You gained a new Contact"))
          new Outcome.GainSpecifiedContact(contact.Name).handleOutcome(currentState);
      }
    }

    public class Rivals : Outcome.EntityToMeet
    {
      public Rivals(int numberToAdd) => this.num = numberToAdd;

      [JsonConstructor]
      public Rivals()
        : this(1)
      {
      }

      public override void handleOutcome(GenerationState currentState)
      {
        foreach (Contact contact in (IEnumerable<Contact>) currentState.peopleSource.getEntityToMeet(this.num, "Uh oh... You gained a new Rival"))
          new Outcome.GainSpecifiedRival(contact.Name).handleOutcome(currentState);
      }
    }

    public class Enemies : Outcome.EntityToMeet
    {
      public Enemies(int numberToAdd) => this.num = numberToAdd;

      [JsonConstructor]
      public Enemies()
        : this(1)
      {
      }

      public override void handleOutcome(GenerationState currentState)
      {
        foreach (Contact contact in (IEnumerable<Contact>) currentState.peopleSource.getEntityToMeet(this.num, "Unfortunately, you made a new Enemy!"))
          new Outcome.GainSpecifiedEnemy(contact.Name).handleOutcome(currentState);
      }
    }

    public class Allies : Outcome.EntityToMeet
    {
      public Allies(int numberToAdd) => this.num = numberToAdd;

      [JsonConstructor]
      public Allies()
        : this(1)
      {
      }

      public override void handleOutcome(GenerationState currentState)
      {
        foreach (Contact contact in (IEnumerable<Contact>) currentState.peopleSource.getEntityToMeet(this.num, "You gained a new Ally!"))
          new Outcome.GainSpecifiedAlly(contact.Name).handleOutcome(currentState);
      }
    }

    public class RandomAmount : Outcome
    {
      [JsonProperty]
      public int min = 0;
      [JsonProperty]
      public int max = 1;
      [JsonProperty]
      public Outcome outcome = (Outcome) null;

      [JsonConstructor]
      public RandomAmount()
      {
      }

      public RandomAmount(int min, int max, Outcome outcome)
      {
        this.min = min;
        this.max = max;
        this.outcome = outcome;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        int num = Dice.random(this.min, this.max);
        for (int index = 0; index < num; ++index)
          this.outcome.handleOutcome(currentState);
      }
    }

    public abstract class GainSpecifiedEntityToMeet : Outcome, ISingleTextOutcome
    {
      [JsonProperty]
      public string entity;

      public GainSpecifiedEntityToMeet()
      {
      }

      public GainSpecifiedEntityToMeet(string entity)
      {
        this.entity = entity;
        this.Description = Utility.toTitleCase(this.GetType().Name) + ": " + entity;
      }

      public override string ToString()
      {
        return "New " + Utility.getLastCapitalizedWord(this.GetType().Name) + ": " + this.entity;
      }

      public virtual string Text
      {
        get => this.entity;
        set => this.entity = value;
      }

      public virtual string TextLabel => (string) null;
    }

    public enum EntityType
    {
      ENEMY,
      RIVAL,
      CONTACT,
      ALLY,
    }

    public class EnsureCharacterHasNumberOfEntityToMeet : 
      Outcome,
      ISingleIntOutcome,
      IComboBoxOutcome
    {
      [JsonProperty]
      internal int minNum = 1;
      [JsonProperty]
      internal Outcome.EntityType myType = Outcome.EntityType.CONTACT;

      [JsonConstructor]
      public EnsureCharacterHasNumberOfEntityToMeet()
      {
      }

      protected internal virtual void ensureNumberOfEntities(Outcome.EntityType type)
      {
        this.myType = type;
        this.minNum = 1;
      }

      public EnsureCharacterHasNumberOfEntityToMeet(int num, Outcome.EntityType type)
      {
        this.minNum = num;
        this.myType = type;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        Character character = currentState.character;
        Outcome outcome = (Outcome) null;
        switch (this.myType)
        {
          case Outcome.EntityType.ENEMY:
            int numberToAdd1 = this.minNum - character.Contacts.Count;
            if (numberToAdd1 > 0)
            {
              outcome = (Outcome) new Outcome.Enemies(numberToAdd1);
              break;
            }
            break;
          case Outcome.EntityType.RIVAL:
            int numberToAdd2 = this.minNum - character.Contacts.Count;
            if (numberToAdd2 > 0)
            {
              outcome = (Outcome) new Outcome.Rivals(numberToAdd2);
              break;
            }
            break;
          case Outcome.EntityType.CONTACT:
            int number_of_contacts = this.minNum - character.Contacts.Count;
            if (number_of_contacts > 0)
            {
              outcome = (Outcome) new Outcome.Contacts(number_of_contacts);
              break;
            }
            break;
          case Outcome.EntityType.ALLY:
            int numberToAdd3 = this.minNum - character.Allies.Count;
            if (numberToAdd3 > 0)
            {
              outcome = (Outcome) new Outcome.Allies(numberToAdd3);
              break;
            }
            break;
          default:
            throw new Exception("Unknown Type Enum" + this.myType.ToString());
        }
        outcome?.handleOutcome(currentState);
      }

      public virtual IList<string> Choices
      {
        get
        {
          List<string> choices = new List<string>();
          foreach (object obj in Enum.GetValues(typeof (Outcome.EntityType)))
            choices.Add(obj.ToString());
          return (IList<string>) choices;
        }
      }

      public virtual string Selected
      {
        set => this.myType = (Outcome.EntityType) Enum.Parse(typeof (Outcome.EntityType), value);
      }

      public virtual int Int
      {
        set
        {
          if (value <= 0)
            return;
          this.minNum = value;
        }
        get => this.minNum;
      }

      public virtual string IntLabel => "Number of entities to ensure the character has";
    }

    public class GainSpecifiedContact : Outcome.GainSpecifiedEntityToMeet
    {
      [JsonConstructor]
      public GainSpecifiedContact()
      {
      }

      public GainSpecifiedContact(string contact)
        : base(contact)
      {
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.character.addContact(this.entity);
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }
    }

    public class GainSpecifiedEnemy : Outcome.GainSpecifiedEntityToMeet
    {
      [JsonConstructor]
      public GainSpecifiedEnemy()
      {
      }

      public GainSpecifiedEnemy(string enemy)
        : base(enemy)
      {
      }

      public GainSpecifiedEnemy(Contact enemy)
        : this(enemy.Name)
      {
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.character.addEnemy(this.entity);
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }
    }

    public class GainSpecifiedAlly : Outcome.GainSpecifiedEntityToMeet
    {
      [JsonConstructor]
      public GainSpecifiedAlly()
      {
      }

      public GainSpecifiedAlly(string ally)
        : base(ally)
      {
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.character.addAlly(this.entity);
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }
    }

    public class GainSpecifiedRival : Outcome.GainSpecifiedEntityToMeet
    {
      [JsonConstructor]
      public GainSpecifiedRival()
      {
      }

      public GainSpecifiedRival(string rival)
        : base(rival)
      {
      }

      public GainSpecifiedRival(Contact rival)
        : this(rival.Name)
      {
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.character.addRival(this.entity);
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }
    }

    public class NextCareerMustBe : Outcome, ISingleTextOutcome
    {
      [JsonProperty]
      public string nextCareer;
      [JsonProperty]
      public bool endCurrentCareer;

      [JsonConstructor]
      public NextCareerMustBe()
      {
      }

      public NextCareerMustBe(string nextCareer, bool endCurrentCareer = false)
      {
        this.nextCareer = nextCareer;
        this.endCurrentCareer = endCurrentCareer;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.nextCarrerMustBe = this.nextCareer;
        if (!this.endCurrentCareer)
          return;
        currentState.endCurrentCareer = true;
      }

      public override string ToString() => "Next career has to be " + this.nextCareer;

      public virtual string Text
      {
        get => this.nextCareer;
        set => this.nextCareer = value;
      }

      public virtual string TextLabel => "Next Career";
    }

    public class NextCareerMayBe : Outcome.NextCareerMustBe
    {
      [JsonProperty]
      private int startingRank = 0;
      [JsonIgnore]
      public static int CURRENT_RANK = -1;

      [JsonConstructor]
      public NextCareerMayBe()
      {
      }

      public NextCareerMayBe(string nextCareer, int startingRank = 0, bool endCurrentCareer = false)
      {
        this.nextCareer = nextCareer;
        this.endCurrentCareer = endCurrentCareer;
        this.startingRank = startingRank;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        Describable describable1 = new Describable("Yes", "I want to be a " + this.nextCareer + ".");
        Describable describable2 = new Describable("No", "Come what may, I don't want to be a  " + this.nextCareer + ".");
        if (currentState.decisionMaker.ChooseOne<Describable>("You may enter/continue as a " + this.nextCareer + " if you so choose, but you don't have. Be a " + this.nextCareer + "?", (IList<Describable>) new List<Describable>()
        {
          describable1,
          describable2
        }) == describable1)
        {
          if (this.startingRank != 0)
          {
            if (this.startingRank == Outcome.NextCareerMayBe.CURRENT_RANK)
              this.startingRank = currentState.character.CurrentTerm.rank;
            currentState.startNextCareerAtRank = this.startingRank;
          }
          base.handleOutcome(currentState);
        }
        else
          currentState.recorder.RecordBenefit(new Outcome("Chose not to change to " + this.nextCareer, describable2.Description), currentState);
      }
    }

    public class AdditionalRollOnSkillsAndTrainingTable : Outcome
    {
      [JsonProperty]
      public const string CURRENT_CAREER = "CURRENT_CAREER";
      [JsonProperty]
      public Outcome.AdditionalRollOnSkillsAndTrainingTable.TableTypes tableType = Outcome.AdditionalRollOnSkillsAndTrainingTable.TableTypes.NormallyAvailable;
      [JsonProperty]
      public string career = nameof (CURRENT_CAREER);

      [JsonConstructor]
      public AdditionalRollOnSkillsAndTrainingTable()
      {
        this.career = nameof (CURRENT_CAREER);
        this.tableType = Outcome.AdditionalRollOnSkillsAndTrainingTable.TableTypes.NormallyAvailable;
      }

      public AdditionalRollOnSkillsAndTrainingTable(
        string careerName,
        Outcome.AdditionalRollOnSkillsAndTrainingTable.TableTypes tableType = Outcome.AdditionalRollOnSkillsAndTrainingTable.TableTypes.NormallyAvailable)
      {
        this.career = careerName;
        tableType = Outcome.AdditionalRollOnSkillsAndTrainingTable.TableTypes.NormallyAvailable;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        string specializationName = currentState.character.CurrentTerm.specializationName;
        Character character = currentState.character;
        Career career = this.career == "CURRENT_CAREER" ? currentState.currentCareer : currentState.careerSource.GetCareer(this.career);
        if (career == null)
          EngineLog.Error("UNABLE TO OBTAIN A REFERENCE TO CAREER [" + this.career + "] for AdditionalRollOnSkillsAndTrainingTable()");
        IList<NamedList<Outcome>> choices = (IList<NamedList<Outcome>>) new List<NamedList<Outcome>>();
        switch (this.tableType)
        {
          case Outcome.AdditionalRollOnSkillsAndTrainingTable.TableTypes.All_Specializations_Only:
            using (IEnumerator<Career.Specialization> enumerator = career.GetApplicableSpecializations(character).GetEnumerator())
            {
              while (enumerator.MoveNext())
              {
                Career.Specialization current = enumerator.Current;
                choices.Add(new NamedList<Outcome>(current.Name, (ICollection<Outcome>) current.SpecializationOutcomeList));
              }
              break;
            }
          default:
            choices = career.getAvailableTables(character);
            break;
        }
        Dice.RollRandomResult<Outcome>("", (IList<Outcome>) currentState.decisionMaker.Choose<NamedList<Outcome>>(1, choices)[0], ContextKeys.OUTCOMES).handleOutcome(currentState);
      }

      public enum TableTypes
      {
        NormallyAvailable,
        All_Specializations_Only,
      }
    }

    public class EnsureStatAtLevel : Outcome, ISingleIntOutcome, ISingleTextOutcome
    {
      [JsonProperty]
      public string statName;
      [JsonProperty]
      public int minLevel;
      [JsonProperty]
      public bool incrementByOneIfOverMinLevel = false;

      [JsonConstructor]
      public EnsureStatAtLevel()
      {
      }

      public EnsureStatAtLevel(string stat, int level)
      {
        this.statName = stat;
        this.minLevel = level;
        this.incrementByOneIfOverMinLevel = false;
      }

      public EnsureStatAtLevel(string stat, int level, bool incrementIfOverLevel)
        : this(stat, level)
      {
        this.incrementByOneIfOverMinLevel = incrementIfOverLevel;
      }

      public override void handleOutcome(GenerationState currentState)
      {
        Attribute attribute = currentState.character.getAttribute(this.statName);
        if (attribute.Value < this.minLevel)
        {
          attribute.Value = this.minLevel;
          attribute.UninjuredValue = this.minLevel;
        }
        else if (this.incrementByOneIfOverMinLevel)
        {
          attribute.Increment();
          ++attribute.UninjuredValue;
        }
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override string ToString()
      {
        string str = "Ensure " + this.statName + " is at least [" + this.minLevel.ToString() + "]";
        if (this.incrementByOneIfOverMinLevel)
          str += ". If it is, increment.";
        return str;
      }

      public virtual int Int
      {
        set => this.minLevel = value;
        get => this.minLevel;
      }

      public virtual string IntLabel => "Minimum Level";

      public virtual string Text
      {
        get => this.statName ?? "";
        set => this.statName = value;
      }

      public virtual string TextLabel => "Attribute Name";
    }

    public abstract class ReduceAttribute : 
      Outcome,
      IDoubleIntOutcome,
      ISingleIntOutcome,
      ISingleBooleanOutcome
    {
      [JsonProperty]
      public bool isToBeRolled = false;
      [JsonProperty]
      public int num_characteristics = 1;
      [JsonProperty]
      public int amount = 1;
      [JsonProperty]
      public string description = nameof (ReduceAttribute);

      public ReduceAttribute()
      {
      }

      public ReduceAttribute(int numAttributes, int amount, bool isToRollValue)
      {
        this.num_characteristics = numAttributes;
        this.amount = amount;
        this.isToBeRolled = isToRollValue;
      }

      protected internal virtual void modifyCharacterStatByAmount(
        GenerationState currentState,
        List<string> attributes)
      {
        string str = "Pick " + this.num_characteristics.ToString() + " characteristic";
        if (this.num_characteristics > 1)
          str += "s";
        string description = str + " to reduce by " + this.amount.ToString() + (this.isToBeRolled ? "D6." : ".");
        currentState.decisionMaker.setQueryKey(ContextKeys.SKILLS);
        IList<string> stringList;
        if (this.num_characteristics >= attributes.Count)
        {
          StringBuilder stringBuilder = new StringBuilder();
          for (int index = 0; index < attributes.Count; ++index)
          {
            if (index != 0)
              stringBuilder.Append(", ");
            if (index == attributes.Count - 1)
              stringBuilder.Append("and ");
            stringBuilder.Append(attributes[index]);
          }
          stringBuilder.Append(" will all be reduced by " + this.amount.ToString() + (this.isToBeRolled ? "D6." : "."));
          currentState.decisionMaker.present(new Presentation(attributes.Count.ToString() + " Stats to be Reduced", stringBuilder.ToString()));
          stringList = (IList<string>) attributes;
        }
        else
          stringList = currentState.decisionMaker.Choose<string>(description, this.num_characteristics, (IList<string>) attributes);
        this.description = "";
        foreach (string characteristic in (IEnumerable<string>) stringList)
        {
          if (this.isToBeRolled)
            this.amount = Dice.D6Roll(this.amount, 0, "Reduce " + characteristic).effect;
          if (currentState.nextOperation != CreationOperation.HANDLE_AGING)
            currentState.character.getAttribute(characteristic).Subtract(this.amount);
          else
            currentState.character.getAttribute(characteristic).Age(this.amount);
          if (this.description.Length > 0)
            this.description += ", ";
          this.description = this.description + "Modified " + characteristic + " by " + (-1 * this.amount).ToString();
        }
        currentState.recorder.RecordBenefit(new Event("Reduce attribute", this.description), currentState);
      }

      public override string ToString() => this.description;

      public virtual int SecondInt
      {
        set => this.amount = value;
        get => this.amount;
      }

      public virtual string SecondIntLabel => "Amount";

      public virtual int Int
      {
        set => this.num_characteristics = value;
        get => this.num_characteristics;
      }

      public virtual string IntLabel => "Number of Attributes to modify";

      public virtual bool Boolean
      {
        get => this.isToBeRolled;
        set => this.isToBeRolled = value;
      }

      public virtual string BooleanLabel => "is Dice";
    }

    public class ReduceMentalAttribute : Outcome.ReduceAttribute
    {
      [JsonConstructor]
      public ReduceMentalAttribute()
      {
      }

      public ReduceMentalAttribute(int numAttributes, int amount)
        : base(numAttributes, amount, false)
      {
        this.description = "Reduce " + numAttributes.ToString() + " mental attribute" + (numAttributes > 1 ? "s " : " ") + "by " + amount.ToString();
      }

      public override void handleOutcome(GenerationState currentState)
      {
        this.modifyCharacterStatByAmount(currentState, new List<string>()
        {
          "Int",
          "Edu"
        });
      }
    }

    public class ReducePhysicalAttribute : Outcome.ReduceAttribute
    {
      [JsonConstructor]
      public ReducePhysicalAttribute()
      {
      }

      public ReducePhysicalAttribute(int numAttributes, int amount)
        : base(numAttributes, amount, false)
      {
        this.description = "Reduce " + numAttributes.ToString() + " physical attribute" + (numAttributes > 1 ? "s " : " ") + "by " + amount.ToString() + (this.isToBeRolled ? "D6." : ".");
      }

      public ReducePhysicalAttribute(int numAttributes, int amount, bool isDice)
        : base(numAttributes, amount, isDice)
      {
        this.description = "Reduce " + numAttributes.ToString() + " physical attribute" + (numAttributes > 1 ? "s " : " ") + "by " + amount.ToString() + (isDice ? "D6." : ".");
      }

      public override void handleOutcome(GenerationState currentState)
      {
        this.modifyCharacterStatByAmount(currentState, new List<string>()
        {
          "Str",
          "Dex",
          "End"
        });
      }
    }

    public class GainAnySkill : Outcome
    {
      [JsonProperty]
      protected bool allowJoAT = false;

      [JsonConstructor]
      public GainAnySkill()
      {
      }

      public GainAnySkill(bool allowJackOfAllTrades) => this.allowJoAT = allowJackOfAllTrades;

      public override string ToString() => "Gain any skill";

      protected override string AutoGenerateName() => "Any skill";

      protected override string AutoGenerateDescription()
      {
        return "You can choose whatever skill you want to learn... You will increase it by 1 level";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        IList<ISkill> list = (IList<ISkill>) currentState.skillSource.Skills.OrderBy<ISkill, string>((Func<ISkill, string>) (s => s.Name)).ToList<ISkill>();
        foreach (ISkill skill in (IEnumerable<ISkill>) list)
        {
          if (!skill.Cascade)
            skill.Level = 1;
        }
        if (!this.allowJoAT)
          list = (IList<ISkill>) list.Where<ISkill>((Func<ISkill, bool>) (s => !s.Name.ToLowerInvariant().Contains("jack") || !s.Name.ToLowerInvariant().Contains("trade"))).ToList<ISkill>();
        new Outcome.GainSkill(currentState.decisionMaker.ChooseOne<ISkill>(list)).handleOutcome(currentState);
      }
    }

    public class GainPension : Outcome.GainMoney
    {
      [JsonConstructor]
      public GainPension()
      {
      }

      public GainPension(int yearlyIncome) => this.amount = yearlyIncome;

      protected override string AutoGenerateName() => "Yearly Pension of " + this.amount.ToString();

      protected override string AutoGenerateDescription()
      {
        return "It's always good to have money. You won't buy a politician for that, but maybe a gun or a cheap friend.";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.character.Pension += this.amount;
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override string ToString()
      {
        return "Gained Yearly Pension of " + this.amount.ToString() + " credits";
      }
    }

    public class SurvivalModifier : Outcome
    {
      [JsonProperty]
      public int modifier = -1;

      [JsonConstructor]
      public SurvivalModifier()
      {
      }

      protected override string AutoGenerateDescription()
      {
        return "You have a friend who knows a thing or two about this career. He sometimes warns you and helps you to avoid trouble. Thanks to him your chance to survive without incidents is now much higher. At least in this term.";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.character.CurrentTerm.survivalModifier += this.modifier;
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override string ToString()
      {
        return "Survival Modifier " + (this.modifier > 0 ? " +" : " ") + this.modifier.ToString();
      }
    }

    public class EnsureAnySkill : Outcome
    {
      [JsonProperty]
      public int minLevel = 1;

      [JsonConstructor]
      public EnsureAnySkill()
      {
      }

      public override void handleOutcome(GenerationState currentState)
      {
        IList<ISkill> list = (IList<ISkill>) Utility.prune<ISkill>(currentState.skillSource.Skills, currentState.character.Skills, this.minLevel).OrderBy<ISkill, string>((Func<ISkill, string>) (s => s.Name)).ToList<ISkill>();
        if (list.Count > 0)
        {
          new Outcome.EnsureSkillAtLevel(currentState.decisionMaker.ChooseOne<ISkill>("Pick one skill to ensure it's at level " + this.minLevel.ToString(), list).Name, this.minLevel).handleOutcome(currentState);
        }
        else
        {
          currentState.decisionMaker.present(new Presentation("Nothing Worth Having", "There wasn't any skill available that you didn't already have or could improve."));
          FeedbackStream.Send("There wasn't any skill available that you didn't already have or could improve.");
        }
      }
    }

    public class GainTalent : Outcome
    {
      [JsonProperty]
      public string talent_name { get; set; }

      [JsonProperty]
      public override string Name
      {
        get
        {
          return string.IsNullOrEmpty(this._name) || base.Name.ToLowerInvariant().Contains("gain") ? this.talent_name : base.Name;
        }
        set => base.Name = value;
      }

      [JsonConstructor]
      public GainTalent()
      {
      }

      public GainTalent(string talent)
      {
        this.talent_name = talent;
        Talent talent1 = DataManager.Instance.Talents.Where<Talent>((Func<Talent, bool>) (t => t.Name.Equals(this.talent_name, StringComparison.InvariantCultureIgnoreCase))).FirstOrDefault<Talent>();
        string description = talent1 != null ? talent1.Description : "";
        if (talent1 == null)
          EngineLog.Error("Talent [" + this.talent_name + "] could not be found.  GainTalent Constructor.");
        this._description = "Gain +1 Level of " + this.talent_name + ".\n" + (talent != null ? description : "");
      }

      public override void handleOutcome(GenerationState currentState)
      {
        Talent addMe = (Talent) null;
        ISkillSource skillSource = currentState.skillSource;
        try
        {
          addMe = currentState.nextOperation != CreationOperation.GET_BASIC_TRAINING && currentState.nextOperation != CreationOperation.GAIN_BACKGROUND_SKILLS && currentState.nextOperation != CreationOperation.SELECT_RACE ? skillSource.getTalent(this.talent_name) : skillSource.getBasicTrainingTalent(this.talent_name);
        }
        catch (Exception ex)
        {
          EngineLog.Print("Wow what happened here, couldn't find talent" + ex?.ToString() + "Talent: " + this.talent_name);
        }
        this.talent_name = addMe.Name + ": " + addMe.Level.ToString();
        if (!currentState.character.hasTalent(addMe.Name))
        {
          if (Dice.Roll(new RollParam(currentState.character.getAttribute(addMe.associatedTrait.associatedAttribute), 8, addMe.learning_dm, "Even though you don't have " + addMe.Name + " you have a new opportunity to learn it.  If you are successful, you'll gain it at 0.")).isSuccessful)
          {
            addMe.Level = 0;
            currentState.character.addTalent(addMe);
            this.Description = "Learned " + addMe.Name + " at 0.";
          }
          else
            this.Description = "Tried to learn " + addMe.Name + " but failed.";
        }
        else if (addMe.Level > 0)
        {
          this.Description = "Increased " + addMe.Name + " by " + addMe.Level.ToString() + ".";
          currentState.character.addTalent(addMe);
        }
        else
          this.Description = "Verified that the talent [" + addMe.Name + "] is already possesed.";
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }

      public override bool Equals(object amIEqual)
      {
        bool flag = false;
        if (amIEqual is Outcome.GainTalent)
        {
          Outcome.GainTalent gainTalent = (Outcome.GainTalent) amIEqual;
          if (this.talent_name != null)
          {
            if (gainTalent != null && gainTalent.talent_name.Equals(this.talent_name, StringComparison.CurrentCultureIgnoreCase))
              flag = true;
          }
          else if (gainTalent.talent_name == null)
            flag = true;
        }
        return flag;
      }

      public override int GetHashCode()
      {
        return typeof (Outcome.GainTalent).GetHashCode() + (this.talent_name != null ? this.talent_name.GetHashCode() : 19);
      }

      public override string ToString() => this.talent_name;
    }

    public class EnsureAnyTalent : Outcome
    {
      [JsonProperty]
      public int minLevel = 1;

      public EnsureAnyTalent() => this._name = "Ensure Any Talent";

      [JsonConstructor]
      public EnsureAnyTalent(int is_at_least)
      {
        this.minLevel = is_at_least;
        this.Description = "Ensure that you have any talent (selected by you) at level " + is_at_least.ToString() + ".  If you don't have the talent, you get it.  If you don't have the talent at " + is_at_least.ToString() + " it gets raised to " + is_at_least.ToString() + ".  If you have the chosen talent at or greater than " + is_at_least.ToString() + " then there is no effect.";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        IList<Talent> list = (IList<Talent>) Utility.prune<Talent>(currentState.skillSource.Talents, currentState.character.Talents, this.minLevel).OrderBy<Talent, string>((Func<Talent, string>) (t => t.Name)).ToList<Talent>();
        if (list.Count > 0)
        {
          new Outcome.EnsureTalentAtLevel(currentState.decisionMaker.ChooseOne<Talent>("Pick one Talent to ensure it's at level " + this.minLevel.ToString(), list).Name, this.minLevel).handleOutcome(currentState);
        }
        else
        {
          currentState.decisionMaker.present(new Presentation("Nothing Worth Having", "There wasn't any talent available that you didn't already have or could improve."));
          FeedbackStream.Send("There wasn't any talnet available that you didn't already have or could improve.");
        }
      }
    }

    public class EnsureTalentAtLevel : Outcome
    {
      [JsonProperty]
      public string talentName;
      [JsonProperty]
      public int minLevel;

      public EnsureTalentAtLevel()
      {
      }

      [JsonConstructor]
      public EnsureTalentAtLevel(string talent, int talentLevel)
      {
        this.talentName = talent;
        this.minLevel = talentLevel;
        this.Name = "Ensure " + this.talentName + " is " + this.minLevel.ToString();
        this.Description = "Ensure that you have " + this.talentName + " at level " + talentLevel.ToString() + ".  If you don't have " + this.talentName + ", you get it.  If you don't have it at " + this.minLevel.ToString() + " it gets raised to " + this.minLevel.ToString() + ".  If you have the chosen talent at or greater than " + this.minLevel.ToString() + " then there is no effect.";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        Character character = currentState.character;
        Talent talent1 = currentState.skillSource.getTalent(this.talentName);
        if (character.hasTalent(talent1.Name))
        {
          Talent talent2 = character.getTalent(this.talentName);
          if (talent2.Level < this.minLevel)
            talent2.Level = this.minLevel;
        }
        else
        {
          talent1.Level = this.minLevel;
          character.addTalent(talent1);
        }
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }
    }

    public class GainAnyTalent : Outcome
    {
      [JsonConstructor]
      public GainAnyTalent()
      {
        this.Name = "Gain Any Talent";
        this.Description = "Select any one talent to gain.  If you do not have the talent, you can test for it.  If you already have the talent, you will gain an additional level of it.";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        IList<Outcome> list = (IList<Outcome>) currentState.skillSource.Talents.OrderBy<Talent, string>((Func<Talent, string>) (t => t.Name)).Select<Talent, Outcome>((Func<Talent, Outcome>) (t => (Outcome) new Outcome.GainTalent(t.Name))).ToList<Outcome>();
        currentState.decisionMaker.ChooseOne<Outcome>(list).handleOutcome(currentState);
      }
    }

    public class GainAnyZhodaniTalent : Outcome
    {
      [JsonConstructor]
      public GainAnyZhodaniTalent()
      {
        this.Name = "Gain Any Zhodani Talent";
        this.Description = "Select any one talent to gain.  If you do not have the talent, you can test for it.  If you already have the talent, you will gain an additional level of it.";
      }

      public override void handleOutcome(GenerationState currentState)
      {
        IList<Talent> source = (IList<Talent>) new List<Talent>();
        foreach (Talent talent in (IEnumerable<Talent>) currentState.skillSource.getTalentsForTrait(Trait.ZHODANI_PSIONIC))
        {
          if (talent.Name.Contains("Zhodani"))
            source.Add(talent);
        }
        IList<Outcome> list = (IList<Outcome>) source.OrderBy<Talent, string>((Func<Talent, string>) (t => t.Name)).Select<Talent, Outcome>((Func<Talent, Outcome>) (t => (Outcome) new Outcome.GainTalent(t.Name))).ToList<Outcome>();
        currentState.decisionMaker.ChooseOne<Outcome>(list).handleOutcome(currentState);
      }
    }

    public class CareerLongAdvancementModifier(int modifier) : Outcome.AdvancementModifier(modifier)
    {
      public new void handleOutcome(GenerationState currentState)
      {
        currentState.careerAdvancementModifier += this.modifier;
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }
    }

    public class CareerLongSurvivalModifier : Outcome.SurvivalModifier
    {
      public CareerLongSurvivalModifier(int survival_modifier) => this.modifier = survival_modifier;

      public override void handleOutcome(GenerationState currentState)
      {
        currentState.careerSurvivalModifier += this.modifier;
        currentState.recorder.RecordBenefit((Outcome) this, currentState);
      }
    }

    public class AddEquipment : Outcome
    {
      [JsonProperty]
      public string EquipmentName { get; set; }

      [JsonProperty]
      public Guid EquipmentGUID { get; set; }

      [JsonProperty]
      public IEquipment ActualEquipment { get; set; }

      public AddEquipment(Guid equipmentGUID)
      {
        this.EquipmentGUID = equipmentGUID;
        IEquipment asset = DataManager.Instance.GetAsset<IEquipment>(equipmentGUID);
        this.EquipmentName = asset.Name;
        this.Description = "Obtain a " + this.EquipmentName + ": " + asset.Description;
      }

      public AddEquipment(IEquipment equipment)
      {
        this.ActualEquipment = equipment;
        this.Name = equipment.Name;
        this.Description = "Obtain a " + this.Name + ": " + equipment.Description;
      }

      [JsonConstructor]
      public AddEquipment()
      {
      }

      public override void handleOutcome(GenerationState currentState)
      {
        if (this.EquipmentGUID != Guid.Empty)
          currentState.character.addEquipment(DataManager.Instance.GetAsset<IEquipment>(this.EquipmentGUID), true);
        else if (this.ActualEquipment != null)
          currentState.character.addEquipment(this.ActualEquipment, true);
        else
          currentState.character.addEquipment(DataManager.Instance.Equipment.Where<IEquipment>((Func<IEquipment, bool>) (e => e.Name.Equals(this.EquipmentName, StringComparison.CurrentCultureIgnoreCase))).ToList<IEquipment>().First<IEquipment>(), true);
      }
    }

    public class InformUser(string title, string description) : Outcome(title, description)
    {
      public override void handleOutcome(GenerationState currentState)
      {
        currentState.decisionMaker.present(new Presentation(this.Name, this.Description));
      }
    }

    public class StayInCareer : Outcome
    {
      public override void handleOutcome(GenerationState currentState)
      {
        currentState.endCurrentCareer = false;
      }
    }

    public class LoseAllyOrContact : Outcome
    {
      public override void handleOutcome(GenerationState currentState)
      {
        Contact contact1 = currentState.character.Contacts.FirstOrDefault<Contact>();
        Contact contact2 = currentState.character.Allies.FirstOrDefault<Contact>();
        Contact contact3 = (Contact) null;
        if (contact1 != null && contact2 != null)
          contact3 = currentState.decisionMaker.ChooseOne<Contact>("Which contact/ally will you lose?", (IList<Contact>) new List<Contact>()
          {
            contact1,
            contact2
          });
        else if (contact1 != null)
          contact3 = contact1;
        else if (contact2 != null)
          contact3 = contact2;
        if (contact3 == null)
          currentState.decisionMaker.present(new Presentation("No one to Lose", "You had neither an ally nor a contact, so you didn't lose anyone."));
        else if (contact3 == contact1)
          currentState.character.removeContact(contact3.Name);
        else
          currentState.character.removeAlly(contact3.Name);
      }
    }
  }
}
